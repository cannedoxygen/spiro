{"ast":null,"code":"// src/services/nftService.js\nimport { ethers } from 'ethers';\n\n// Replace with your actual NFT contract address on Base network\nconst NFT_CONTRACT_ADDRESS = \"0x0000000000000000000000000000000000000000\"; // REPLACE WITH REAL ADDRESS\n\n// Replace with your actual SPIRO token contract address\nconst TOKEN_CONTRACT_ADDRESS = \"0x0000000000000000000000000000000000000000\"; // REPLACE WITH REAL ADDRESS\n\n// Simplified ABI for NFT contract\nconst NFT_ABI = [\n// Function to check if a token ID exists\n\"function exists(uint256 tokenId) view returns (bool)\",\n// Function to mint a new NFT\n\"function mint(uint256 tokenId) external\",\n// Function to get token count\n\"function totalSupply() view returns (uint256)\",\n// Function to get tokens owned by an address\n\"function tokensOfOwner(address owner) view returns (uint256[])\",\n// Function to get token metadata URI\n\"function tokenURI(uint256 tokenId) view returns (string)\"];\n\n// Simplified ABI for ERC-20 token contract\nconst TOKEN_ABI = [\n// Function to check token balance\n\"function balanceOf(address owner) view returns (uint256)\",\n// Function to approve tokens\n\"function approve(address spender, uint256 amount) returns (bool)\",\n// Function to transfer tokens\n\"function transfer(address recipient, uint256 amount) returns (bool)\"];\n\n// Get the provider\nconst getProvider = () => {\n  if (window.ethereum) {\n    return new ethers.providers.Web3Provider(window.ethereum);\n  }\n  // Fallback to a read-only provider if no wallet connected\n  return new ethers.providers.JsonRpcProvider('https://mainnet.base.org');\n};\n\n// Get signer for transactions\nconst getSigner = async () => {\n  if (!window.ethereum) {\n    throw new Error(\"No ethereum object found. Please install MetaMask.\");\n  }\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  return provider.getSigner();\n};\n\n// Check token balance\nexport const getTokenBalance = async walletAddress => {\n  try {\n    if (!walletAddress) return \"0\";\n    const provider = getProvider();\n    const tokenContract = new ethers.Contract(TOKEN_CONTRACT_ADDRESS, TOKEN_ABI, provider);\n    const balance = await tokenContract.balanceOf(walletAddress);\n    return balance.toString();\n  } catch (error) {\n    console.error('Error getting token balance:', error);\n    return \"0\";\n  }\n};\n\n// Approve tokens for spending\nexport const approveTokens = async (spenderAddress, amount) => {\n  try {\n    const signer = await getSigner();\n    const tokenContract = new ethers.Contract(TOKEN_CONTRACT_ADDRESS, TOKEN_ABI, signer);\n    const tx = await tokenContract.approve(spenderAddress, amount);\n    await tx.wait();\n    return {\n      success: true,\n      transaction: tx.hash\n    };\n  } catch (error) {\n    console.error('Error approving tokens:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n// Burn tokens (transfer to dead address)\nexport const burnTokens = async amount => {\n  try {\n    const signer = await getSigner();\n    const tokenContract = new ethers.Contract(TOKEN_CONTRACT_ADDRESS, TOKEN_ABI, signer);\n    const burnAddress = \"0x000000000000000000000000000000000000dEaD\";\n    const tx = await tokenContract.transfer(burnAddress, amount);\n    await tx.wait();\n    return {\n      success: true,\n      transaction: tx.hash\n    };\n  } catch (error) {\n    console.error('Error burning tokens:', error);\n    return {\n      success: false,\n      error: error.message\n    };\n  }\n};\n\n// Check if a token ID is already minted\nexport const isSeedAvailable = async seed => {\n  try {\n    const provider = getProvider();\n    const contract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, provider);\n\n    // Check if the token exists\n    const exists = await contract.exists(seed);\n    return !exists;\n  } catch (error) {\n    console.error('Error checking if seed is available:', error);\n    // For graceful degradation in case of RPC issues\n    return true;\n  }\n};\n\n// Get the count of minted NFTs\nexport const getMintedCount = async () => {\n  try {\n    const provider = getProvider();\n    const contract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, provider);\n    const totalSupply = await contract.totalSupply();\n    return totalSupply.toNumber();\n  } catch (error) {\n    console.error('Error getting minted count:', error);\n    // For graceful degradation, use localStorage as fallback\n    try {\n      const mintedSeeds = JSON.parse(localStorage.getItem('mintedSeeds')) || [];\n      return mintedSeeds.length;\n    } catch {\n      return 0;\n    }\n  }\n};\n\n// Find an available seed\nexport const findAvailableSeed = async () => {\n  try {\n    // Generate a random seed between 1 and 10000\n    const randomSeed = Math.floor(Math.random() * 10000) + 1;\n\n    // Check if this seed is available\n    const available = await isSeedAvailable(randomSeed);\n    if (available) {\n      return randomSeed;\n    }\n\n    // If not available, try a sequential search for an available seed\n    for (let i = 1; i <= 10000; i++) {\n      const isAvailable = await isSeedAvailable(i);\n      if (isAvailable) {\n        return i;\n      }\n    }\n\n    // If all 10,000 tokens are minted, return null\n    return null;\n  } catch (error) {\n    console.error('Error finding available seed:', error);\n    // Fallback to a random number if there's an issue\n    return Math.floor(Math.random() * 10000) + 1;\n  }\n};\n\n// Reserve a seed (mint the token)\nexport const reserveSeed = async seed => {\n  try {\n    // Check if the seed is available first\n    const available = await isSeedAvailable(seed);\n    if (!available) {\n      return {\n        success: false,\n        message: \"This design has already been minted!\"\n      };\n    }\n    const signer = await getSigner();\n    const contract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, signer);\n\n    // Mint the token\n    const tx = await contract.mint(seed);\n\n    // Wait for the transaction to be confirmed\n    await tx.wait();\n\n    // Also save locally for immediate UI updates\n    try {\n      const mintedSeeds = JSON.parse(localStorage.getItem('mintedSeeds')) || [];\n      mintedSeeds.push(seed);\n      localStorage.setItem('mintedSeeds', JSON.stringify(mintedSeeds));\n    } catch (e) {\n      console.error('Error updating local storage:', e);\n    }\n    return {\n      success: true,\n      transaction: tx.hash\n    };\n  } catch (error) {\n    console.error('Error reserving seed:', error);\n    return {\n      success: false,\n      message: error.message || \"Error minting NFT\"\n    };\n  }\n};\n\n// Get user's minted NFTs\nexport const getUserNFTs = async walletAddress => {\n  try {\n    if (!walletAddress) {\n      throw new Error(\"Wallet address is required\");\n    }\n    const provider = getProvider();\n    const contract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, provider);\n\n    // Get token IDs owned by the user\n    const tokenIds = await contract.tokensOfOwner(walletAddress);\n\n    // Get metadata for each token\n    const nfts = await Promise.all(tokenIds.map(async id => {\n      const tokenId = id.toNumber();\n      const uri = await contract.tokenURI(tokenId);\n\n      // If URI is IPFS, format properly\n      let metadataUrl = uri;\n      if (uri.startsWith('ipfs://')) {\n        metadataUrl = uri.replace('ipfs://', 'https://ipfs.io/ipfs/');\n      }\n\n      // Fetch metadata\n      try {\n        var _metadata$image, _metadata$attributes;\n        const response = await fetch(metadataUrl);\n        const metadata = await response.json();\n        return {\n          id: tokenId,\n          name: metadata.name || `Spirograph #${tokenId}`,\n          image: ((_metadata$image = metadata.image) === null || _metadata$image === void 0 ? void 0 : _metadata$image.replace('ipfs://', 'https://ipfs.io/ipfs/')) || '',\n          params: ((_metadata$attributes = metadata.attributes) === null || _metadata$attributes === void 0 ? void 0 : _metadata$attributes.reduce((acc, attr) => {\n            acc[attr.trait_type.toLowerCase()] = attr.value;\n            return acc;\n          }, {})) || {},\n          mintDate: new Date().toISOString() // NFT contracts typically don't store mint date\n        };\n      } catch (error) {\n        console.error(`Error fetching metadata for token ${tokenId}:`, error);\n        return {\n          id: tokenId,\n          name: `Spirograph #${tokenId}`,\n          image: '',\n          params: {},\n          mintDate: new Date().toISOString()\n        };\n      }\n    }));\n    return nfts;\n  } catch (error) {\n    console.error('Error getting user NFTs:', error);\n\n    // For graceful degradation, fall back to local storage\n    try {\n      return JSON.parse(localStorage.getItem('userNFTs')) || [];\n    } catch (e) {\n      return [];\n    }\n  }\n};\n\n// Save an NFT to IPFS and mint it\nexport const saveUserNFT = async nftData => {\n  try {\n    // In a real implementation, you would:\n    // 1. Upload the image to IPFS\n    // 2. Create metadata and upload to IPFS\n    // 3. Call the contract to mint with the IPFS URI\n\n    // For now, we'll just save to localStorage as a fallback\n    const userNFTs = JSON.parse(localStorage.getItem('userNFTs')) || [];\n    userNFTs.push(nftData);\n    localStorage.setItem('userNFTs', JSON.stringify(userNFTs));\n    return true;\n  } catch (error) {\n    console.error('Error saving NFT:', error);\n    return false;\n  }\n};\n\n// Helper for collection page\nexport const formatCollectionData = nfts => {\n  return nfts.map(nft => ({\n    id: nft.id,\n    image: nft.image,\n    params: nft.params,\n    mintDate: nft.mintDate\n  }));\n};","map":{"version":3,"names":["ethers","NFT_CONTRACT_ADDRESS","TOKEN_CONTRACT_ADDRESS","NFT_ABI","TOKEN_ABI","getProvider","window","ethereum","providers","Web3Provider","JsonRpcProvider","getSigner","Error","provider","getTokenBalance","walletAddress","tokenContract","Contract","balance","balanceOf","toString","error","console","approveTokens","spenderAddress","amount","signer","tx","approve","wait","success","transaction","hash","message","burnTokens","burnAddress","transfer","isSeedAvailable","seed","contract","exists","getMintedCount","totalSupply","toNumber","mintedSeeds","JSON","parse","localStorage","getItem","length","findAvailableSeed","randomSeed","Math","floor","random","available","i","isAvailable","reserveSeed","mint","push","setItem","stringify","e","getUserNFTs","tokenIds","tokensOfOwner","nfts","Promise","all","map","id","tokenId","uri","tokenURI","metadataUrl","startsWith","replace","_metadata$image","_metadata$attributes","response","fetch","metadata","json","name","image","params","attributes","reduce","acc","attr","trait_type","toLowerCase","value","mintDate","Date","toISOString","saveUserNFT","nftData","userNFTs","formatCollectionData","nft"],"sources":["/Users/cannedoxygen/Downloads/spiro/src/services/nftService.js"],"sourcesContent":["// src/services/nftService.js\nimport { ethers } from 'ethers';\n\n// Replace with your actual NFT contract address on Base network\nconst NFT_CONTRACT_ADDRESS = \"0x0000000000000000000000000000000000000000\"; // REPLACE WITH REAL ADDRESS\n\n// Replace with your actual SPIRO token contract address\nconst TOKEN_CONTRACT_ADDRESS = \"0x0000000000000000000000000000000000000000\"; // REPLACE WITH REAL ADDRESS\n\n// Simplified ABI for NFT contract\nconst NFT_ABI = [\n  // Function to check if a token ID exists\n  \"function exists(uint256 tokenId) view returns (bool)\",\n  \n  // Function to mint a new NFT\n  \"function mint(uint256 tokenId) external\",\n  \n  // Function to get token count\n  \"function totalSupply() view returns (uint256)\",\n  \n  // Function to get tokens owned by an address\n  \"function tokensOfOwner(address owner) view returns (uint256[])\",\n  \n  // Function to get token metadata URI\n  \"function tokenURI(uint256 tokenId) view returns (string)\"\n];\n\n// Simplified ABI for ERC-20 token contract\nconst TOKEN_ABI = [\n  // Function to check token balance\n  \"function balanceOf(address owner) view returns (uint256)\",\n  \n  // Function to approve tokens\n  \"function approve(address spender, uint256 amount) returns (bool)\",\n  \n  // Function to transfer tokens\n  \"function transfer(address recipient, uint256 amount) returns (bool)\"\n];\n\n// Get the provider\nconst getProvider = () => {\n  if (window.ethereum) {\n    return new ethers.providers.Web3Provider(window.ethereum);\n  }\n  // Fallback to a read-only provider if no wallet connected\n  return new ethers.providers.JsonRpcProvider('https://mainnet.base.org');\n};\n\n// Get signer for transactions\nconst getSigner = async () => {\n  if (!window.ethereum) {\n    throw new Error(\"No ethereum object found. Please install MetaMask.\");\n  }\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  return provider.getSigner();\n};\n\n// Check token balance\nexport const getTokenBalance = async (walletAddress) => {\n  try {\n    if (!walletAddress) return \"0\";\n    \n    const provider = getProvider();\n    const tokenContract = new ethers.Contract(\n      TOKEN_CONTRACT_ADDRESS,\n      TOKEN_ABI,\n      provider\n    );\n    \n    const balance = await tokenContract.balanceOf(walletAddress);\n    return balance.toString();\n  } catch (error) {\n    console.error('Error getting token balance:', error);\n    return \"0\";\n  }\n};\n\n// Approve tokens for spending\nexport const approveTokens = async (spenderAddress, amount) => {\n  try {\n    const signer = await getSigner();\n    const tokenContract = new ethers.Contract(\n      TOKEN_CONTRACT_ADDRESS,\n      TOKEN_ABI,\n      signer\n    );\n    \n    const tx = await tokenContract.approve(spenderAddress, amount);\n    await tx.wait();\n    return { success: true, transaction: tx.hash };\n  } catch (error) {\n    console.error('Error approving tokens:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n// Burn tokens (transfer to dead address)\nexport const burnTokens = async (amount) => {\n  try {\n    const signer = await getSigner();\n    const tokenContract = new ethers.Contract(\n      TOKEN_CONTRACT_ADDRESS,\n      TOKEN_ABI,\n      signer\n    );\n    \n    const burnAddress = \"0x000000000000000000000000000000000000dEaD\";\n    const tx = await tokenContract.transfer(burnAddress, amount);\n    await tx.wait();\n    return { success: true, transaction: tx.hash };\n  } catch (error) {\n    console.error('Error burning tokens:', error);\n    return { success: false, error: error.message };\n  }\n};\n\n// Check if a token ID is already minted\nexport const isSeedAvailable = async (seed) => {\n  try {\n    const provider = getProvider();\n    const contract = new ethers.Contract(\n      NFT_CONTRACT_ADDRESS, \n      NFT_ABI,\n      provider\n    );\n    \n    // Check if the token exists\n    const exists = await contract.exists(seed);\n    return !exists;\n  } catch (error) {\n    console.error('Error checking if seed is available:', error);\n    // For graceful degradation in case of RPC issues\n    return true;\n  }\n};\n\n// Get the count of minted NFTs\nexport const getMintedCount = async () => {\n  try {\n    const provider = getProvider();\n    const contract = new ethers.Contract(\n      NFT_CONTRACT_ADDRESS, \n      NFT_ABI,\n      provider\n    );\n    \n    const totalSupply = await contract.totalSupply();\n    return totalSupply.toNumber();\n  } catch (error) {\n    console.error('Error getting minted count:', error);\n    // For graceful degradation, use localStorage as fallback\n    try {\n      const mintedSeeds = JSON.parse(localStorage.getItem('mintedSeeds')) || [];\n      return mintedSeeds.length;\n    } catch {\n      return 0;\n    }\n  }\n};\n\n// Find an available seed\nexport const findAvailableSeed = async () => {\n  try {\n    // Generate a random seed between 1 and 10000\n    const randomSeed = Math.floor(Math.random() * 10000) + 1;\n    \n    // Check if this seed is available\n    const available = await isSeedAvailable(randomSeed);\n    if (available) {\n      return randomSeed;\n    }\n    \n    // If not available, try a sequential search for an available seed\n    for (let i = 1; i <= 10000; i++) {\n      const isAvailable = await isSeedAvailable(i);\n      if (isAvailable) {\n        return i;\n      }\n    }\n    \n    // If all 10,000 tokens are minted, return null\n    return null;\n  } catch (error) {\n    console.error('Error finding available seed:', error);\n    // Fallback to a random number if there's an issue\n    return Math.floor(Math.random() * 10000) + 1;\n  }\n};\n\n// Reserve a seed (mint the token)\nexport const reserveSeed = async (seed) => {\n  try {\n    // Check if the seed is available first\n    const available = await isSeedAvailable(seed);\n    if (!available) {\n      return { success: false, message: \"This design has already been minted!\" };\n    }\n    \n    const signer = await getSigner();\n    const contract = new ethers.Contract(\n      NFT_CONTRACT_ADDRESS, \n      NFT_ABI,\n      signer\n    );\n    \n    // Mint the token\n    const tx = await contract.mint(seed);\n    \n    // Wait for the transaction to be confirmed\n    await tx.wait();\n    \n    // Also save locally for immediate UI updates\n    try {\n      const mintedSeeds = JSON.parse(localStorage.getItem('mintedSeeds')) || [];\n      mintedSeeds.push(seed);\n      localStorage.setItem('mintedSeeds', JSON.stringify(mintedSeeds));\n    } catch (e) {\n      console.error('Error updating local storage:', e);\n    }\n    \n    return { success: true, transaction: tx.hash };\n  } catch (error) {\n    console.error('Error reserving seed:', error);\n    return { success: false, message: error.message || \"Error minting NFT\" };\n  }\n};\n\n// Get user's minted NFTs\nexport const getUserNFTs = async (walletAddress) => {\n  try {\n    if (!walletAddress) {\n      throw new Error(\"Wallet address is required\");\n    }\n    \n    const provider = getProvider();\n    const contract = new ethers.Contract(\n      NFT_CONTRACT_ADDRESS, \n      NFT_ABI,\n      provider\n    );\n    \n    // Get token IDs owned by the user\n    const tokenIds = await contract.tokensOfOwner(walletAddress);\n    \n    // Get metadata for each token\n    const nfts = await Promise.all(tokenIds.map(async (id) => {\n      const tokenId = id.toNumber();\n      const uri = await contract.tokenURI(tokenId);\n      \n      // If URI is IPFS, format properly\n      let metadataUrl = uri;\n      if (uri.startsWith('ipfs://')) {\n        metadataUrl = uri.replace('ipfs://', 'https://ipfs.io/ipfs/');\n      }\n      \n      // Fetch metadata\n      try {\n        const response = await fetch(metadataUrl);\n        const metadata = await response.json();\n        \n        return {\n          id: tokenId,\n          name: metadata.name || `Spirograph #${tokenId}`,\n          image: metadata.image?.replace('ipfs://', 'https://ipfs.io/ipfs/') || '',\n          params: metadata.attributes?.reduce((acc, attr) => {\n            acc[attr.trait_type.toLowerCase()] = attr.value;\n            return acc;\n          }, {}) || {},\n          mintDate: new Date().toISOString() // NFT contracts typically don't store mint date\n        };\n      } catch (error) {\n        console.error(`Error fetching metadata for token ${tokenId}:`, error);\n        return {\n          id: tokenId,\n          name: `Spirograph #${tokenId}`,\n          image: '',\n          params: {},\n          mintDate: new Date().toISOString()\n        };\n      }\n    }));\n    \n    return nfts;\n  } catch (error) {\n    console.error('Error getting user NFTs:', error);\n    \n    // For graceful degradation, fall back to local storage\n    try {\n      return JSON.parse(localStorage.getItem('userNFTs')) || [];\n    } catch (e) {\n      return [];\n    }\n  }\n};\n\n// Save an NFT to IPFS and mint it\nexport const saveUserNFT = async (nftData) => {\n  try {\n    // In a real implementation, you would:\n    // 1. Upload the image to IPFS\n    // 2. Create metadata and upload to IPFS\n    // 3. Call the contract to mint with the IPFS URI\n    \n    // For now, we'll just save to localStorage as a fallback\n    const userNFTs = JSON.parse(localStorage.getItem('userNFTs')) || [];\n    userNFTs.push(nftData);\n    localStorage.setItem('userNFTs', JSON.stringify(userNFTs));\n    \n    return true;\n  } catch (error) {\n    console.error('Error saving NFT:', error);\n    return false;\n  }\n};\n\n// Helper for collection page\nexport const formatCollectionData = (nfts) => {\n  return nfts.map(nft => ({\n    id: nft.id,\n    image: nft.image,\n    params: nft.params,\n    mintDate: nft.mintDate\n  }));\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}