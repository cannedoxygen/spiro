{"ast":null,"code":"// src/services/nftService.js\nimport { ethers } from 'ethers';\n\n// Replace with your actual NFT contract address on Base network\nconst NFT_CONTRACT_ADDRESS = \"0x0000000000000000000000000000000000000000\"; // REPLACE WITH REAL ADDRESS\n\n// Simplified ABI for NFT contract\nconst NFT_ABI = [\n// Function to check if a token ID exists\n\"function exists(uint256 tokenId) view returns (bool)\",\n// Function to mint a new NFT\n\"function mint(uint256 tokenId) external\",\n// Function to get token count\n\"function totalSupply() view returns (uint256)\",\n// Function to get tokens owned by an address\n\"function tokensOfOwner(address owner) view returns (uint256[])\",\n// Function to get token metadata URI\n\"function tokenURI(uint256 tokenId) view returns (string)\"];\n\n// Get the provider\nconst getProvider = () => {\n  if (window.ethereum) {\n    return new ethers.providers.Web3Provider(window.ethereum);\n  }\n  // Fallback to a read-only provider if no wallet connected\n  return new ethers.providers.JsonRpcProvider('https://mainnet.base.org');\n};\n\n// Get signer for transactions\nconst getSigner = async () => {\n  if (!window.ethereum) {\n    throw new Error(\"No ethereum object found. Please install MetaMask.\");\n  }\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  return provider.getSigner();\n};\n\n// Check if a token ID is already minted\nexport const isSeedAvailable = async seed => {\n  try {\n    const provider = getProvider();\n    const contract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, provider);\n\n    // Check if the token exists\n    const exists = await contract.exists(seed);\n    return !exists;\n  } catch (error) {\n    console.error('Error checking if seed is available:', error);\n    // For graceful degradation in case of RPC issues\n    return true;\n  }\n};\n\n// Get the count of minted NFTs\nexport const getMintedCount = async () => {\n  try {\n    const provider = getProvider();\n    const contract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, provider);\n    const totalSupply = await contract.totalSupply();\n    return totalSupply.toNumber();\n  } catch (error) {\n    console.error('Error getting minted count:', error);\n    // For graceful degradation, use localStorage as fallback\n    try {\n      const mintedSeeds = JSON.parse(localStorage.getItem('mintedSeeds')) || [];\n      return mintedSeeds.length;\n    } catch {\n      return 0;\n    }\n  }\n};\n\n// Find an available seed\nexport const findAvailableSeed = async () => {\n  try {\n    // Generate a random seed between 1 and 10000\n    const randomSeed = Math.floor(Math.random() * 10000) + 1;\n\n    // Check if this seed is available\n    const available = await isSeedAvailable(randomSeed);\n    if (available) {\n      return randomSeed;\n    }\n\n    // If not available, try a sequential search for an available seed\n    for (let i = 1; i <= 10000; i++) {\n      const isAvailable = await isSeedAvailable(i);\n      if (isAvailable) {\n        return i;\n      }\n    }\n\n    // If all 10,000 tokens are minted, return null\n    return null;\n  } catch (error) {\n    console.error('Error finding available seed:', error);\n    // Fallback to a random number if there's an issue\n    return Math.floor(Math.random() * 10000) + 1;\n  }\n};\n\n// Reserve a seed (mint the token)\nexport const reserveSeed = async seed => {\n  try {\n    // Check if the seed is available first\n    const available = await isSeedAvailable(seed);\n    if (!available) {\n      return {\n        success: false,\n        message: \"This design has already been minted!\"\n      };\n    }\n    const signer = await getSigner();\n    const contract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, signer);\n\n    // Mint the token\n    const tx = await contract.mint(seed);\n\n    // Wait for the transaction to be confirmed\n    await tx.wait();\n\n    // Also save locally for immediate UI updates\n    try {\n      const mintedSeeds = JSON.parse(localStorage.getItem('mintedSeeds')) || [];\n      mintedSeeds.push(seed);\n      localStorage.setItem('mintedSeeds', JSON.stringify(mintedSeeds));\n    } catch (e) {\n      console.error('Error updating local storage:', e);\n    }\n    return {\n      success: true,\n      transaction: tx.hash\n    };\n  } catch (error) {\n    console.error('Error reserving seed:', error);\n    return {\n      success: false,\n      message: error.message || \"Error minting NFT\"\n    };\n  }\n};\n\n// Get user's minted NFTs\nexport const getUserNFTs = async walletAddress => {\n  try {\n    if (!walletAddress) {\n      throw new Error(\"Wallet address is required\");\n    }\n    const provider = getProvider();\n    const contract = new ethers.Contract(NFT_CONTRACT_ADDRESS, NFT_ABI, provider);\n\n    // Get token IDs owned by the user\n    const tokenIds = await contract.tokensOfOwner(walletAddress);\n\n    // Get metadata for each token\n    const nfts = await Promise.all(tokenIds.map(async id => {\n      const tokenId = id.toNumber();\n      const uri = await contract.tokenURI(tokenId);\n\n      // If URI is IPFS, format properly\n      let metadataUrl = uri;\n      if (uri.startsWith('ipfs://')) {\n        metadataUrl = uri.replace('ipfs://', 'https://ipfs.io/ipfs/');\n      }\n\n      // Fetch metadata\n      try {\n        var _metadata$image, _metadata$attributes;\n        const response = await fetch(metadataUrl);\n        const metadata = await response.json();\n        return {\n          id: tokenId,\n          name: metadata.name || `Spirograph #${tokenId}`,\n          image: ((_metadata$image = metadata.image) === null || _metadata$image === void 0 ? void 0 : _metadata$image.replace('ipfs://', 'https://ipfs.io/ipfs/')) || '',\n          params: ((_metadata$attributes = metadata.attributes) === null || _metadata$attributes === void 0 ? void 0 : _metadata$attributes.reduce((acc, attr) => {\n            acc[attr.trait_type.toLowerCase()] = attr.value;\n            return acc;\n          }, {})) || {},\n          mintDate: new Date().toISOString() // NFT contracts typically don't store mint date\n        };\n      } catch (error) {\n        console.error(`Error fetching metadata for token ${tokenId}:`, error);\n        return {\n          id: tokenId,\n          name: `Spirograph #${tokenId}`,\n          image: '',\n          params: {},\n          mintDate: new Date().toISOString()\n        };\n      }\n    }));\n    return nfts;\n  } catch (error) {\n    console.error('Error getting user NFTs:', error);\n\n    // For graceful degradation, fall back to local storage\n    try {\n      return JSON.parse(localStorage.getItem('userNFTs')) || [];\n    } catch (e) {\n      return [];\n    }\n  }\n};\n\n// Save an NFT to IPFS and mint it\nexport const saveUserNFT = async nftData => {\n  try {\n    // In a real implementation, you would:\n    // 1. Upload the image to IPFS\n    // 2. Create metadata and upload to IPFS\n    // 3. Call the contract to mint with the IPFS URI\n\n    // For now, we'll just save to localStorage as a fallback\n    const userNFTs = JSON.parse(localStorage.getItem('userNFTs')) || [];\n    userNFTs.push(nftData);\n    localStorage.setItem('userNFTs', JSON.stringify(userNFTs));\n    return true;\n  } catch (error) {\n    console.error('Error saving NFT:', error);\n    return false;\n  }\n};\n\n// Helper for collection page\nexport const formatCollectionData = nfts => {\n  return nfts.map(nft => ({\n    id: nft.id,\n    image: nft.image,\n    params: nft.params,\n    mintDate: nft.mintDate\n  }));\n};","map":{"version":3,"names":["ethers","NFT_CONTRACT_ADDRESS","NFT_ABI","getProvider","window","ethereum","providers","Web3Provider","JsonRpcProvider","getSigner","Error","provider","isSeedAvailable","seed","contract","Contract","exists","error","console","getMintedCount","totalSupply","toNumber","mintedSeeds","JSON","parse","localStorage","getItem","length","findAvailableSeed","randomSeed","Math","floor","random","available","i","isAvailable","reserveSeed","success","message","signer","tx","mint","wait","push","setItem","stringify","e","transaction","hash","getUserNFTs","walletAddress","tokenIds","tokensOfOwner","nfts","Promise","all","map","id","tokenId","uri","tokenURI","metadataUrl","startsWith","replace","_metadata$image","_metadata$attributes","response","fetch","metadata","json","name","image","params","attributes","reduce","acc","attr","trait_type","toLowerCase","value","mintDate","Date","toISOString","saveUserNFT","nftData","userNFTs","formatCollectionData","nft"],"sources":["/Users/cannedoxygen/Downloads/spiro/src/services/nftService.js"],"sourcesContent":["// src/services/nftService.js\nimport { ethers } from 'ethers';\n\n// Replace with your actual NFT contract address on Base network\nconst NFT_CONTRACT_ADDRESS = \"0x0000000000000000000000000000000000000000\"; // REPLACE WITH REAL ADDRESS\n\n// Simplified ABI for NFT contract\nconst NFT_ABI = [\n  // Function to check if a token ID exists\n  \"function exists(uint256 tokenId) view returns (bool)\",\n  \n  // Function to mint a new NFT\n  \"function mint(uint256 tokenId) external\",\n  \n  // Function to get token count\n  \"function totalSupply() view returns (uint256)\",\n  \n  // Function to get tokens owned by an address\n  \"function tokensOfOwner(address owner) view returns (uint256[])\",\n  \n  // Function to get token metadata URI\n  \"function tokenURI(uint256 tokenId) view returns (string)\"\n];\n\n// Get the provider\nconst getProvider = () => {\n  if (window.ethereum) {\n    return new ethers.providers.Web3Provider(window.ethereum);\n  }\n  // Fallback to a read-only provider if no wallet connected\n  return new ethers.providers.JsonRpcProvider('https://mainnet.base.org');\n};\n\n// Get signer for transactions\nconst getSigner = async () => {\n  if (!window.ethereum) {\n    throw new Error(\"No ethereum object found. Please install MetaMask.\");\n  }\n  const provider = new ethers.providers.Web3Provider(window.ethereum);\n  return provider.getSigner();\n};\n\n// Check if a token ID is already minted\nexport const isSeedAvailable = async (seed) => {\n  try {\n    const provider = getProvider();\n    const contract = new ethers.Contract(\n      NFT_CONTRACT_ADDRESS, \n      NFT_ABI,\n      provider\n    );\n    \n    // Check if the token exists\n    const exists = await contract.exists(seed);\n    return !exists;\n  } catch (error) {\n    console.error('Error checking if seed is available:', error);\n    // For graceful degradation in case of RPC issues\n    return true;\n  }\n};\n\n// Get the count of minted NFTs\nexport const getMintedCount = async () => {\n  try {\n    const provider = getProvider();\n    const contract = new ethers.Contract(\n      NFT_CONTRACT_ADDRESS, \n      NFT_ABI,\n      provider\n    );\n    \n    const totalSupply = await contract.totalSupply();\n    return totalSupply.toNumber();\n  } catch (error) {\n    console.error('Error getting minted count:', error);\n    // For graceful degradation, use localStorage as fallback\n    try {\n      const mintedSeeds = JSON.parse(localStorage.getItem('mintedSeeds')) || [];\n      return mintedSeeds.length;\n    } catch {\n      return 0;\n    }\n  }\n};\n\n// Find an available seed\nexport const findAvailableSeed = async () => {\n  try {\n    // Generate a random seed between 1 and 10000\n    const randomSeed = Math.floor(Math.random() * 10000) + 1;\n    \n    // Check if this seed is available\n    const available = await isSeedAvailable(randomSeed);\n    if (available) {\n      return randomSeed;\n    }\n    \n    // If not available, try a sequential search for an available seed\n    for (let i = 1; i <= 10000; i++) {\n      const isAvailable = await isSeedAvailable(i);\n      if (isAvailable) {\n        return i;\n      }\n    }\n    \n    // If all 10,000 tokens are minted, return null\n    return null;\n  } catch (error) {\n    console.error('Error finding available seed:', error);\n    // Fallback to a random number if there's an issue\n    return Math.floor(Math.random() * 10000) + 1;\n  }\n};\n\n// Reserve a seed (mint the token)\nexport const reserveSeed = async (seed) => {\n  try {\n    // Check if the seed is available first\n    const available = await isSeedAvailable(seed);\n    if (!available) {\n      return { success: false, message: \"This design has already been minted!\" };\n    }\n    \n    const signer = await getSigner();\n    const contract = new ethers.Contract(\n      NFT_CONTRACT_ADDRESS, \n      NFT_ABI,\n      signer\n    );\n    \n    // Mint the token\n    const tx = await contract.mint(seed);\n    \n    // Wait for the transaction to be confirmed\n    await tx.wait();\n    \n    // Also save locally for immediate UI updates\n    try {\n      const mintedSeeds = JSON.parse(localStorage.getItem('mintedSeeds')) || [];\n      mintedSeeds.push(seed);\n      localStorage.setItem('mintedSeeds', JSON.stringify(mintedSeeds));\n    } catch (e) {\n      console.error('Error updating local storage:', e);\n    }\n    \n    return { success: true, transaction: tx.hash };\n  } catch (error) {\n    console.error('Error reserving seed:', error);\n    return { success: false, message: error.message || \"Error minting NFT\" };\n  }\n};\n\n// Get user's minted NFTs\nexport const getUserNFTs = async (walletAddress) => {\n  try {\n    if (!walletAddress) {\n      throw new Error(\"Wallet address is required\");\n    }\n    \n    const provider = getProvider();\n    const contract = new ethers.Contract(\n      NFT_CONTRACT_ADDRESS, \n      NFT_ABI,\n      provider\n    );\n    \n    // Get token IDs owned by the user\n    const tokenIds = await contract.tokensOfOwner(walletAddress);\n    \n    // Get metadata for each token\n    const nfts = await Promise.all(tokenIds.map(async (id) => {\n      const tokenId = id.toNumber();\n      const uri = await contract.tokenURI(tokenId);\n      \n      // If URI is IPFS, format properly\n      let metadataUrl = uri;\n      if (uri.startsWith('ipfs://')) {\n        metadataUrl = uri.replace('ipfs://', 'https://ipfs.io/ipfs/');\n      }\n      \n      // Fetch metadata\n      try {\n        const response = await fetch(metadataUrl);\n        const metadata = await response.json();\n        \n        return {\n          id: tokenId,\n          name: metadata.name || `Spirograph #${tokenId}`,\n          image: metadata.image?.replace('ipfs://', 'https://ipfs.io/ipfs/') || '',\n          params: metadata.attributes?.reduce((acc, attr) => {\n            acc[attr.trait_type.toLowerCase()] = attr.value;\n            return acc;\n          }, {}) || {},\n          mintDate: new Date().toISOString() // NFT contracts typically don't store mint date\n        };\n      } catch (error) {\n        console.error(`Error fetching metadata for token ${tokenId}:`, error);\n        return {\n          id: tokenId,\n          name: `Spirograph #${tokenId}`,\n          image: '',\n          params: {},\n          mintDate: new Date().toISOString()\n        };\n      }\n    }));\n    \n    return nfts;\n  } catch (error) {\n    console.error('Error getting user NFTs:', error);\n    \n    // For graceful degradation, fall back to local storage\n    try {\n      return JSON.parse(localStorage.getItem('userNFTs')) || [];\n    } catch (e) {\n      return [];\n    }\n  }\n};\n\n// Save an NFT to IPFS and mint it\nexport const saveUserNFT = async (nftData) => {\n  try {\n    // In a real implementation, you would:\n    // 1. Upload the image to IPFS\n    // 2. Create metadata and upload to IPFS\n    // 3. Call the contract to mint with the IPFS URI\n    \n    // For now, we'll just save to localStorage as a fallback\n    const userNFTs = JSON.parse(localStorage.getItem('userNFTs')) || [];\n    userNFTs.push(nftData);\n    localStorage.setItem('userNFTs', JSON.stringify(userNFTs));\n    \n    return true;\n  } catch (error) {\n    console.error('Error saving NFT:', error);\n    return false;\n  }\n};\n\n// Helper for collection page\nexport const formatCollectionData = (nfts) => {\n  return nfts.map(nft => ({\n    id: nft.id,\n    image: nft.image,\n    params: nft.params,\n    mintDate: nft.mintDate\n  }));\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}